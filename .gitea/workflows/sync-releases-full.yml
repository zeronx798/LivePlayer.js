# 工作流名称
name: Manual - Full Sync All Releases to GitHub

# 触发器：仅手动触发
on:
  workflow_dispatch:

jobs:
  full-sync:
    runs-on: linux-amd64 # 您自托管 Runner 的标签
    steps:
      # 步骤 1: 从 Gitea API 获取所有 Release 的元数据
      # 这个工作流现在只关心 Release 的元数据，不关心 Git 本身。
      - name: 'Fetch All Releases MetaData from Gitea'
        run: |
          echo "Fetching list of all releases from Gitea (the source of truth)..."
          # 为了获取所有 release，可能需要分页。这里简化为最多获取 100 个。
          # 如有需要可以添加分页逻辑。
          curl -L --fail -H "Authorization: token ${{ secrets.GITEA_TOKEN }}" \
            "${{ gitea.server_url }}/api/v1/repos/${{ gitea.repository }}/releases?limit=100" \
            -o releases.json
          if [ ! -s releases.json ]; then
            echo "::warning::Failed to fetch releases from Gitea or repository has no releases."
          fi
          echo "Found $(jq '. | length' releases.json) releases to process from Gitea."

      # 步骤 2: 清理 GitHub 上的所有旧 Release 对象 (【保留】所有标签)
      # 标签由 'Sync Code and Tags' 工作流管理，这里绝对不能碰。
      - name: 'Wipe All Existing Releases on GitHub (Keep Tags)'
        env:
          GH_TOKEN: ${{ secrets.G_GITHUB_TOKEN }}
        run: |
          echo "Fetching all existing releases from GitHub to delete them..."
          # 使用 gh cli 获取所有 release 关联的 tag 名
          TAGS_TO_DELETE=$(gh release list --repo "${{ secrets.G_GITHUB_REPO }}" --limit 500 --json tagName -q '.[] | .tagName')

          if [ -z "$TAGS_TO_DELETE" ]; then
            echo "No existing releases found on GitHub. Nothing to delete."
          else
            echo "The following GitHub releases will be DELETED (tags will be KEPT):"
            echo "$TAGS_TO_DELETE"
            echo "$TAGS_TO_DELETE" | while IFS= read -r tag; do
              echo "--> Deleting GitHub release object for tag: $tag"
              # 【关键】这里只删除 release 对象，绝不使用 --cleanup-tag
              gh release delete "$tag" --repo "${{ secrets.G_GITHUB_REPO }}" --yes 2>/dev/null || true
            done
            echo "All pre-existing release objects on GitHub have been wiped."
          fi

      # 步骤 3: 按【从旧到新】的顺序在 GitHub 上重建所有 Release
      # 这样可以完美保留 Gitea 上的原始顺序和日期
      - name: 'Recreate All Releases on GitHub in Chronological Order'
        env:
          GH_TOKEN: ${{ secrets.G_GITHUB_TOKEN }}
        run: |
          if [ ! -s releases.json ]; then
            echo "Gitea has no releases. GitHub is now clean. Job finished."
            exit 0
          fi
        
          # 【关键】使用 jq 的 reverse 命令反转数组，实现从旧到新处理
          # 这样创建出来的 Release 就会按正确的日期排序
          while IFS= read -r release_json; do
            # 变量提取逻辑保持不变
            RELEASE_ID=$(echo "$release_json" | jq -r .id)
            TAG_NAME=$(echo "$release_json" | jq -r .tag_name)
            RELEASE_NAME=$(echo "$release_json" | jq -r .name)
            RELEASE_BODY=$(echo "$release_json" | jq -r .body)
            IS_PRERELEASE=$(echo "$release_json" | jq -r .prerelease)
            ASSETS_JSON=$(echo "$release_json" | jq -c .assets)

            echo "====================================================="
            echo "Recreating Release: $RELEASE_NAME (Tag: $TAG_NAME)"

            # 下载附件逻辑保持不变
            rm -rf ./temp_assets && mkdir -p ./temp_assets
            ASSET_PATHS=()
            if [ "$ASSETS_JSON" != "null" ] && [ "$(echo "$ASSETS_JSON" | jq 'length')" -gt 0 ]; then
              while IFS= read -r asset_json; do
                ASSET_ID=$(echo "$asset_json" | jq -r .id)
                ASSET_NAME=$(echo "$asset_json" | jq -r .name)
                FILE_PATH="./temp_assets/$ASSET_NAME"
                ASSET_API_URL="${{ gitea.server_url }}/api/v1/repos/${{ gitea.repository }}/releases/${RELEASE_ID}/assets/${ASSET_ID}"
                curl -L --fail -H "Authorization: token ${{ secrets.GITEA_TOKEN }}" -o "$FILE_PATH" "$ASSET_API_URL"
                ASSET_PATHS+=("$FILE_PATH")
              done < <(echo "$ASSETS_JSON" | jq -c '.[]')
            fi

            # 创建 Release 逻辑保持不变
            echo "$RELEASE_BODY" > "notes_${TAG_NAME}.txt"
            CREATE_ARGS=( "$TAG_NAME" --repo "${{ secrets.G_GITHUB_REPO }}" --title "$RELEASE_NAME" --notes-file "notes_${TAG_NAME}.txt" )
            if [ "$IS_PRERELEASE" = "true" ]; then CREATE_ARGS+=(--prerelease); fi
            if [ ${#ASSET_PATHS[@]} -gt 0 ]; then CREATE_ARGS+=("${ASSET_PATHS[@]}"); fi
            
            # gh release create 会自动找到 GitHub 上已存在的同名标签并附加 release
            gh release create "${CREATE_ARGS[@]}"
            
            if [ $? -ne 0 ]; then
                echo "::error::'gh release create' failed for tag $TAG_NAME."
                exit 1
            fi
            rm "notes_${TAG_NAME}.txt"
            echo "SUCCESS: Recreated release $RELEASE_NAME on GitHub."

          done < <(jq -c '. | reverse | .[]' releases.json)